<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bom para Voar - Drone Pulveriza√ß√£o</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    .search-container {
      position: relative;
      display: flex;
      width: 100%;
    }
    .search-button {
      position: absolute;
      right: 0;
      top: 0;
      height: 100%;
      padding: 0 12px;
      background: #3B82F6;
      color: white;
      border: none;
      border-radius: 0 8px 8px 0;
      cursor: pointer;
    }
    .search-button:hover {
      background: #2563EB;
    }
    #citySuggestions {
      position: absolute;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ddd;
      border-radius: 0 0 8px 8px;
      z-index: 10;
      display: none;
    }
    .suggestion-item {
      padding: 8px 12px;
      cursor: pointer;
    }
    .suggestion-item:hover {
      background-color: #f0f0f0;
    }
    .dark-mode body {
      background-color: #1a202c;
      color: #e2e8f0;
    }
    .dark-mode .bg-gray-100 {
      background-color: #2d3748;
    }
    .dark-mode .bg-gray-200 {
      background-color: #4a5568;
    }
    .dark-mode .text-gray-900 {
      color: #e2e8f0;
    }
    .dark-mode .bg-white {
      background-color: #2d3748;
      color: #e2e8f0;
    }
    .dark-mode #citySuggestions {
      background-color: #2d3748;
      color: #e2e8f0;
      border-color: #4a5568;
    }
    .dark-mode .suggestion-item:hover {
      background-color: #4a5568;
    }
    .forecast-card {
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .forecast-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-900">
  <div class="max-w-4xl mx-auto p-4">
    <div class="flex justify-between items-center mb-4">
      <h1 class="text-2xl font-bold">Bom para Voar - Drone Pulveriza√ß√£o</h1>
      <button 
        id="themeToggle" 
        class="p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200"
        title="Alternar tema claro/escuro"
      >
        <i class="fas fa-moon" id="themeIcon"></i>
      </button>
    </div>
    
    <div class="flex flex-col sm:flex-row gap-4 mb-4">
      <div class="flex-1 relative">
        <input 
          type="text" 
          id="cityInput" 
          placeholder="Digite a cidade para pulverizar (ex: Bauru, SP)" 
          class="w-full p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:text-white"
          autocomplete="off"
        >
        <div id="citySuggestions" class="hidden"></div>
        <button 
          onclick="buscarPorCidade()" 
          class="absolute right-0 top-0 h-full px-3 bg-blue-500 text-white rounded-r-lg hover:bg-blue-600"
        >
          <i class="fas fa-search"></i>
        </button>
      </div>
      
      <button 
        onclick="solicitarLocalizacao()" 
        class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg whitespace-nowrap"
        id="locationButton"
      >
        <i class="fas fa-map-marker-alt mr-2"></i>Minha Localiza√ß√£o
      </button>
    </div>
    
    <div id="status" class="text-center p-4 mb-4 rounded-lg bg-gray-200 dark:bg-gray-700 dark:text-white">
      <i class="fas fa-info-circle mr-2"></i>Digite uma cidade ou use sua localiza√ß√£o
    </div>
    
    <div id="grid" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6"></div>
    
    <div class="border-t-2 border-gray-300 dark:border-gray-600 my-6"></div>
    
    <h2 class="text-xl font-bold mb-4">Pr√≥ximas Horas</h2>
    <div id="forecastGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-4"></div>
  </div>

  <script>
    const grid = document.getElementById("grid");
    const forecastGrid = document.getElementById("forecastGrid");
    const statusBox = document.getElementById("status");
    const cityInput = document.getElementById("cityInput");
    const citySuggestions = document.getElementById("citySuggestions");
    const locationButton = document.getElementById("locationButton");
    const themeToggle = document.getElementById("themeToggle");
    const themeIcon = document.getElementById("themeIcon");

    // Configura√ß√£o da quantidade de cards de previs√£o
    const QTD_PREVISOES = 5;

    // Tema
    const savedTheme = localStorage.getItem('theme') || 
                      (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    if (savedTheme === 'dark') {
      document.documentElement.classList.add('dark-mode');
      themeIcon.classList.replace('fa-moon', 'fa-sun');
    }

    themeToggle.addEventListener('click', () => {
      document.documentElement.classList.toggle('dark-mode');
      
      if (document.documentElement.classList.contains('dark-mode')) {
        themeIcon.classList.replace('fa-moon', 'fa-sun');
        localStorage.setItem('theme', 'dark');
      } else {
        themeIcon.classList.replace('fa-sun', 'fa-moon');
        localStorage.setItem('theme', 'light');
      }
    });

    let ultimaBusca = null;
    let usandoGPS = false;
    let ultimaLocalizacao = null;

    // Autocompletar
    let sugestaoAbortCtrl = null;
    cityInput.addEventListener("input", async function() {
      const termo = this.value.trim();
      citySuggestions.innerHTML = "";

      if (termo.length < 2) {
        citySuggestions.style.display = "none";
        citySuggestions.classList.add("hidden");
        return;
      }

      try {
        if (sugestaoAbortCtrl) sugestaoAbortCtrl.abort();
        sugestaoAbortCtrl = new AbortController();

        const resp = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(termo)}&limit=7&accept-language=pt-BR`,
          { signal: sugestaoAbortCtrl.signal, headers: { "Accept": "application/json" } }
        );
        const dados = await resp.json();

        if (!Array.isArray(dados) || dados.length === 0) {
          citySuggestions.style.display = "none";
          citySuggestions.classList.add("hidden");
          return;
        }

        dados.forEach(item => {
          const div = document.createElement("div");
          div.className = "suggestion-item";
          div.textContent = item.display_name;
          div.onclick = () => {
            cityInput.value = item.display_name;
            citySuggestions.style.display = "none";
            citySuggestions.classList.add("hidden");
            buscarPorCidade();
          };
          citySuggestions.appendChild(div);
        });

        citySuggestions.classList.remove("hidden");
        citySuggestions.style.display = "block";
      } catch (e) {
        citySuggestions.style.display = "none";
        citySuggestions.classList.add("hidden");
      }
    });

    cityInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") buscarPorCidade();
    });

    document.addEventListener("click", function(e) {
      if (!citySuggestions.contains(e.target) && e.target !== cityInput) {
        citySuggestions.style.display = "none";
        citySuggestions.classList.add("hidden");
      }
    });

    function mostrarStatus(mensagem, tipo = 'info') {
      const cores = {
        info: 'bg-gray-200 dark:bg-gray-700',
        success: 'bg-green-400 dark:bg-green-600',
        warning: 'bg-yellow-400 dark:bg-yellow-600',
        error: 'bg-red-400 dark:bg-red-600'
      };
      const icones = {
        info: 'fa-info-circle',
        success: 'fa-check-circle',
        warning: 'fa-exclamation-circle',
        error: 'fa-exclamation-triangle'
      };
      
      statusBox.className = `text-center p-4 mb-4 rounded-lg ${cores[tipo]} dark:text-white`;
      statusBox.innerHTML = `<i class="fas ${icones[tipo]} mr-2"></i>${mensagem}`;
    }

    async function solicitarLocalizacao() {
      mostrarStatus('Obtendo sua localiza√ß√£o...', 'info');
      locationButton.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Buscando...';
      locationButton.disabled = true;

      if (!navigator.geolocation) {
        mostrarStatus('Geolocaliza√ß√£o n√£o suportada pelo navegador', 'error');
        locationButton.innerHTML = '<i class="fas fa-map-marker-alt mr-2"></i>Minha Localiza√ß√£o';
        locationButton.disabled = false;
        return;
      }

      try {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(
            resolve, 
            reject, 
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
            }
          );
        });

        ultimaLocalizacao = {
          lat: position.coords.latitude,
          lon: position.coords.longitude
        };
        
        const cidade = await obterNomeCidade(position.coords.latitude, position.coords.longitude);
        cityInput.value = cidade;
        
        await buscarDadosMeteorologicos(position.coords.latitude, position.coords.longitude, cidade);
      } catch (error) {
        console.error('Erro na geolocaliza√ß√£o:', error);
        mostrarStatus('N√£o foi poss√≠vel obter sua localiza√ß√£o. Verifique as permiss√µes do navegador.', 'error');
      } finally {
        locationButton.innerHTML = '<i class="fas fa-map-marker-alt mr-2"></i>Minha Localiza√ß√£o';
        locationButton.disabled = false;
      }
    }

    async function obterNomeCidade(lat, lon) {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&accept-language=pt-BR`);
        const data = await response.json();
        return data.address.city || data.address.town || data.address.village || 
               data.address.municipality || data.address.county || "Sua Localiza√ß√£o";
      } catch (error) {
        console.error('Erro ao obter nome da cidade:', error);
        return "Sua Localiza√ß√£o";
      }
    }

    async function buscarPorCidade() {
      const cidade = cityInput.value.trim();
      if (!cidade) {
        mostrarStatus('Digite uma cidade para buscar', 'warning');
        return;
      }

      mostrarStatus(`Buscando dados para ${cidade}...`, 'info');

      try {
        const coords = await obterCoordenadasCidadeAPI(cidade);
        if (coords) {
          await buscarDadosMeteorologicos(coords.lat, coords.lon, cidade);
        } else {
          mostrarStatus('Cidade n√£o encontrada', 'error');
        }
      } catch (error) {
        console.error('Erro ao buscar cidade:', error);
        mostrarStatus('Erro ao buscar dados da cidade', 'error');
      }
    }

    async function obterCoordenadasCidadeAPI(cidade) {
      try {
        const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(cidade)}&limit=1&accept-language=pt-BR`);
        const data = await response.json();
        if (Array.isArray(data) && data.length > 0) {
          return {
            lat: parseFloat(data[0].lat),
            lon: parseFloat(data[0].lon)
          };
        }
        return null;
      } catch (error) {
        console.error('Erro na geocodifica√ß√£o:', error);
        return null;
      }
    }

    async function buscarDadosMeteorologicos(lat, lon, cidade) {
      try {
        const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,relativehumidity_2m,precipitation,weathercode,windspeed_10m,windgusts_10m,visibility&timezone=auto`);
        const data = await response.json();
        
        const agora = new Date();
        const horaAtual = agora.getHours();

        // C√°lculos instant√¢neos
        const pontoOrvalho = (data.current_weather.temperature - ((100 - data.hourly.relativehumidity_2m[horaAtual]) / 5)).toFixed(1);
        
        // Montar previs√µes a partir da HORA ATUAL
        const times = data.hourly.time.map(t => new Date(t).getTime());
        const nowMs = Date.now();

        // Pegamos o √≠ndice do "slot" de hora corrente (√∫ltima hora <= agora)
        let startIdx = times.findIndex(ms => ms > nowMs);
        if (startIdx === -1) startIdx = times.length; // tudo no passado
        startIdx = Math.max(0, startIdx - 1);

        const previsao = data.hourly.time
          .slice(startIdx, startIdx + QTD_PREVISOES)
          .map((time, i) => {
            const idx = startIdx + i;
            const d = new Date(time);
            return {
              hora: d.getHours(), // 0..23
              temp: data.hourly.temperature_2m[idx],
              vento: data.hourly.windspeed_10m[idx],
              chuva: data.hourly.precipitation[idx],
              umidade: data.hourly.relativehumidity_2m[idx],
              pontoOrvalho: (data.hourly.temperature_2m[idx] - ((100 - data.hourly.relativehumidity_2m[idx]) / 5)).toFixed(1),
              deltaT: (data.hourly.temperature_2m[idx] - (data.hourly.temperature_2m[idx] - ((100 - data.hourly.relativehumidity_2m[idx]) / 5))).toFixed(1),
              iconeClima: obterIconeDoWeatherCode(data.hourly.weathercode[idx]),
              condicao: interpretarWeatherCode(data.hourly.weathercode[idx]),
              isAgora: i === 0 // primeiro card representa a hora corrente
            };
          });

        const dados = {
          atual: {
            condicao: interpretarWeatherCode(data.current_weather.weathercode),
            iconeClima: obterIconeDoWeatherCode(data.current_weather.weathercode),
            temp: data.current_weather.temperature,
            umidade: data.hourly.relativehumidity_2m[horaAtual],
            vento: data.current_weather.windspeed,
            rajada: data.hourly.windgusts_10m[horaAtual],
            direcaoVento: direcaoVento(data.current_weather.winddirection),
            chuva: data.hourly.precipitation[horaAtual],
            visibilidade: (data.hourly.visibility[horaAtual] / 1000).toFixed(1),
            pontoOrvalho: pontoOrvalho,
            deltaT: (data.current_weather.temperature - pontoOrvalho).toFixed(1),
            atualizado: agora.toLocaleTimeString(),
            localizacao: cidade
          },
          previsao // j√° vem limitado a QTD_PREVISOES
        };
        
        exibirDados(dados.atual, dados.previsao);
        ultimaBusca = { lat, lon, cidade };
        usandoGPS = !!cidade;
      } catch (error) {
        console.error('Erro na API meteorol√≥gica:', error);
        mostrarStatus('Erro ao buscar dados meteorol√≥gicos', 'error');
      }
    }

    function interpretarWeatherCode(code) {
      const codes = {
        0: "C√©u limpo",
        1: "Poucas nuvens",
        2: "Parcialmente nublado",
        3: "Nublado",
        45: "Nevoeiro",
        48: "Nevoeiro com geada",
        51: "Chuvisco leve",
        53: "Chuvisco moderado",
        55: "Chuvisco denso",
        56: "Chuvisco congelante leve",
        57: "Chuvisco congelante denso",
        61: "Chuva leve",
        63: "Chuva moderada",
        65: "Chuva forte",
        66: "Chuva congelante leve",
        67: "Chuva congelante forte",
        71: "Queda de neve leve",
        73: "Queda de neve moderada",
        75: "Queda de neve forte",
        77: "Gr√£os de neve",
        80: "Pancadas de chuva leves",
        81: "Pancadas de chuva moderadas",
        82: "Pancadas de chuva violentas",
        85: "Pancadas de neve leves",
        86: "Pancadas de neve pesadas",
        95: "Trovoada",
        96: "Trovoada com chuva leve",
        99: "Trovoada com chuva forte"
      };
      return codes[code] || `C√≥digo ${code}`;
    }

    function obterIconeDoWeatherCode(code) {
      if (code === 0) return 'fa-sun';
      if (code >= 1 && code <= 3) return 'fa-cloud-sun';
      if (code >= 45 && code <= 57) return 'fa-cloud-rain';
      if (code >= 61 && code <= 67) return 'fa-cloud-showers-heavy';
      if (code >= 71 && code <= 77) return 'fa-snowflake';
      if (code >= 80 && code <= 86) return 'fa-cloud-rain';
      if (code >= 95 && code <= 99) return 'fa-bolt';
      return 'fa-cloud';
    }

    function direcaoVento(graus) {
      const direcoes = ['Norte', 'Nordeste', 'Leste', 'Sudeste', 'Sul', 'Sudoeste', 'Oeste', 'Noroeste'];
      return direcoes[Math.round(graus / 45) % 8];
    }

    function exibirDados(dadosAtuais, previsao) {
      grid.innerHTML = "";
      forecastGrid.innerHTML = "";

      // Armazenar os dados atuais originais para poder restaurar depois
      const dadosAtuaisOriginais = {...dadosAtuais};
      let dadosExibidosAtualmente = {...dadosAtuais};

      const atualizarDadosPrincipais = (dados) => {
        dadosExibidosAtualmente = {...dados};
        const pontoOrvalho = dados.pontoOrvalho || (dados.temp - ((100 - dados.umidade) / 5)).toFixed(1);
        const deltaT = dados.deltaT || (dados.temp - pontoOrvalho).toFixed(1);

        const condicoes = {
          vento: dados.vento <= 15,
          rajada: dados.rajada <= 25,
          chuva: dados.chuva <= 0.2,
          visibilidade: dados.visibilidade >= 5,
          deltaT: deltaT >= 2 && deltaT <= 8,
          umidade: dados.umidade >= 40 && dados.umidade <= 70
        };

        const okCount = Object.values(condicoes).filter(Boolean).length;

        let statusVoo, statusCor, statusIcone;
        if (okCount === 6) {
          statusVoo = "‚úÖ BOM PARA VOAR - Condi√ß√µes ideais para pulveriza√ß√£o!";
          statusCor = "bg-green-400 dark:bg-green-600";
          statusIcone = "fa-check-circle";
        } else if (okCount >= 4) {
          statusVoo = "üü° FAVOR√ÅVEL - Avalie com cautela";
          statusCor = "bg-yellow-400 dark:bg-yellow-600";
          statusIcone = "fa-exclamation-circle";
        } else if (okCount >= 2) {
          statusVoo = "üü† N√ÉO FAVOR√ÅVEL - Ajuste par√¢metros";
          statusCor = "bg-orange-400 dark:bg-orange-600";
          statusIcone = "fa-exclamation-triangle";
        } else {
          statusVoo = "‚ùå RUIM PARA VOAR - Condi√ß√µes desfavor√°veis";
          statusCor = "bg-red-400 dark:bg-red-600";
          statusIcone = "fa-times-circle";
        }

        // Atualizar os blocos principais
        grid.innerHTML = "";
        const blocosAtuais = [
          { nome: "Condi√ß√£o", valor: dados.condicao, icone: dados.iconeClima, cor: "bg-blue-100 dark:bg-blue-900" },
          { nome: "Temperatura", valor: `${dados.temp}¬∞C`, icone: "fa-temperature-high", cor: corStatus(dados.temp, 10, 30, true) },
          { nome: "Umidade", valor: `${dados.umidade}%`, icone: "fa-tint", cor: corStatus(dados.umidade, 30, 70) },
          { nome: "Ponto de Orvalho", valor: `${pontoOrvalho}¬∞C`, icone: "fa-tint", cor: corStatus(pontoOrvalho, 10, 15) },
          { nome: "Delta T", valor: `${deltaT}¬∞C`, icone: "fa-thermometer-half", cor: corStatus(deltaT, 2, 8) },
          { nome: "Vento", valor: `${dados.vento} km/h ${dados.direcaoVento}`, icone: "fa-wind", cor: corStatus(dados.vento, 15, 25) },
          { nome: "Rajadas", valor: `${dados.rajada} km/h`, icone: "fa-wind", cor: corStatus(dados.rajada, 25, 35) },
          { nome: "Chuva", valor: `${dados.chuva}mm`, icone: "fa-cloud-rain", cor: corStatus(dados.chuva, 0.5, 2) },
          { nome: "Visibilidade", valor: `${dados.visibilidade} km`, icone: "fa-eye", cor: corStatus(dados.visibilidade, 5, 3, true) },
          { nome: "Atualizado", valor: dados.atualizado, icone: "fa-clock", cor: "bg-gray-200 dark:bg-gray-700" }
        ];

        blocosAtuais.forEach(b => {
          const div = document.createElement("div");
          div.className = `${b.cor} p-4 rounded-lg flex flex-col items-center text-center dark:text-white`;
          div.innerHTML = `
            <div class="font-bold mb-1">${b.nome}</div>
            <i class="fas ${b.icone} text-xl mb-1"></i>
            <div>${b.valor}</div>
          `;
          grid.appendChild(div);
        });

        // Atualizar o status box
        statusBox.className = `text-center p-4 mb-4 rounded-lg ${statusCor} dark:text-white`;
        statusBox.innerHTML = `<i class="fas ${statusIcone} mr-2"></i>${statusVoo}`;
      };

      // Exibir os dados atuais inicialmente
      atualizarDadosPrincipais(dadosAtuaisOriginais);

      // Renderizar os cards de previs√£o
      previsao.forEach((p, idx) => {
        const textoHora = idx === 0 ? "Agora" : `${p.hora}h`;
        
        const condicoesHora = {
          vento: p.vento <= 15,
          chuva: p.chuva <= 0.2,
          umidade: p.umidade >= 40 && p.umidade <= 70,
          deltaT: p.deltaT >= 2 && p.deltaT <= 8
        };
        
        const okCountHora = Object.values(condicoesHora).filter(Boolean).length;
        let statusCorHora = '';
        
        if (okCountHora === 4) statusCorHora = 'bg-green-100 dark:bg-green-900';
        else if (okCountHora >= 2) statusCorHora = 'bg-yellow-100 dark:bg-yellow-900';
        else statusCorHora = 'bg-red-100 dark:bg-red-900';

        const card = document.createElement("div");
        card.className = `forecast-card ${statusCorHora} p-3 rounded-lg shadow text-center dark:text-white flex flex-col items-center`;
        card.innerHTML = `
          <div class="font-bold mb-1">${textoHora}</div>
          <i class="fas ${p.iconeClima} text-xl my-1"></i>
          <div class="my-1">${p.temp}¬∞C</div>
          <div class="text-xs">Vento: ${p.vento} km/h</div>
          <div class="text-xs">Chuva: ${p.chuva}mm</div>
        `;

        card.addEventListener('click', () => {
          if (idx === 0) {
            // Se clicar no "Agora", volta para os dados originais
            atualizarDadosPrincipais(dadosAtuaisOriginais);
          } else {
            // Para outras horas, mostra os dados daquela hora
            const dadosHora = {
              ...p,
              rajada: p.vento * 1.5, // Estimativa de rajada
              visibilidade: 10, // Valor padr√£o
              direcaoVento: "Vari√°vel", // N√£o temos essa info na previs√£o
              atualizado: new Date().toLocaleTimeString(),
              localizacao: dadosAtuaisOriginais.localizacao,
              iconeClima: p.iconeClima,
              condicao: p.condicao
            };
            atualizarDadosPrincipais(dadosHora);
          }
        });

        forecastGrid.appendChild(card);
      });
    }

    function corStatus(valor, min, max, invertido = false) {
      let verde = invertido ? valor >= max : valor <= min;
      let amarelo = invertido ? (valor < max && valor >= min) : (valor > min && valor <= max);
      if (verde) return "bg-green-300 dark:bg-green-700";
      if (amarelo) return "bg-yellow-300 dark:bg-yellow-700";
      return "bg-red-300 dark:bg-red-700";
    }
  </script>
</body>
</html>
